<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<databaseChangeLog xmlns="http://www.liquibase.org/xml/ns/dbchangelog"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.liquibase.org/xml/ns/dbchangelog http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-2.0.xsd">

	<changeSet author="sh" id="1" runOnChange="true" context="aggr">
		<comment>Aggregation mit Berücksichtigung von Zeitzonen</comment>
		<createProcedure>
<![CDATA[	
CREATE OR REPLACE FUNCTION aggr_calculate()
  RETURNS boolean AS
$BODY$ declare
  val_last int4;
  val_cur  int4;
  bol boolean;
  begin 
   select into val_last value::int from sys_variablen where name like 'aggr_last_his_massendaten_id' ;
   select into val_cur nextval('his_massendaten_id');
   if (not found) then 
    raise exception 'Variable definition not found in sys_variable.';
   end if;
   if (val_last is null) then
    -- Full Aggregation of all 
    select into bol aggr_full();
   else
    -- Delta Mode
     select into bol aggr_inkrement(val_last);   
   end if;
   update sys_variablen set value = CAST(val_cur as varchar) where name like 'aggr_last_his_massendaten_id';
  return(true);
  end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  ]]>
		</createProcedure>
		<createProcedure>
<![CDATA[
CREATE OR REPLACE FUNCTION aggr_full()
  RETURNS boolean AS
$BODY$ declare
   rec record;
   bol boolean;
   i int4 := 0;
   curr_tz text := '';
 begin
raise notice 'Starting aggregation in mode full';
for rec in select m.*,tz.name as timezone from v_messung_massendaten m, timezone tz where m.id_super != 117846 and m.fk_timezone_id=tz.id order by fk_timezone_id
   loop
    if rec.timezone!=curr_tz then
	curr_tz:=rec.timezone;
	--raise notice 'Setting time zone to :%',rec.timezone;
        execute 'set time zone '''||rec.timezone||'''';
     end if;
    i := i+1;
    raise notice 'i:% Messung:%',i,rec.id;
    select into bol aggr_full(rec.id,rec.aufloesung,rec.id_intervaltyp,true);
   end loop;
   return(true);
  end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  ]]>
		</createProcedure>
		<createProcedure>
<![CDATA[
CREATE OR REPLACE FUNCTION aggr_intervall(_intervall interval, _id_intervall integer, _his_id integer)
  RETURNS boolean AS
$BODY$ declare
  mrec record;
  hrec record;
  rec record;
  bol boolean;
  curr_tz text:='';
  begin
  for hrec in select tz.name as timezone, his.id, 
  case when typ.bezeichnung like 'end' then date_trunc(_intervall,his.von - get_intervall(mes.aufloesung)) else date_trunc(_intervall,his.von) end as anchor  
  from his_massendaten his, messungen mes, intervaltyp typ, timezone tz where mes.fk_timezone_id=tz.id and mes.id = his.id and typ.id = mes.id_intervaltyp and his.his_id > _his_id group by 1,2,3 order by 1,2,3
    loop
     if hrec.timezone!=curr_tz then
	curr_tz:=hrec.timezone;
	--raise notice 'Setting time zone to :%',hrec.timezone;
        execute 'set time zone '''||hrec.timezone||'''';
     end if;
     
	 select into mrec get_min_intervall(mes.aufloesung) as min_intervall, 
     case when typ.bezeichnung like 'end' then get_intervall(mes.aufloesung) 
     else '0 min'::interval end as shift 
     from messungen mes, intervaltyp typ where mes.id = hrec.id and typ.id = mes.id_intervaltyp;
	 
     for rec in select id as fid, name as fname, get_aggr_table(id,_id_intervall) as dtable , get_aggr_table(id,get_aggr_src_id(_intervall)) as stable from aggr_funktion	 
     loop
       if _intervall > mrec.min_intervall then
        select into bol aggr_row(rec.stable,rec.dtable,rec.fname,hrec.id,hrec.anchor,_intervall,mrec.shift);
       elsif _intervall = mrec.min_intervall then
	select into bol aggr_row(null,rec.dtable,rec.fname,hrec.id,hrec.anchor,_intervall,mrec.shift);
       end if;
     end loop;
    
	end loop;
  return(true);
  end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
]]>
		</createProcedure>
	</changeSet>

	<changeSet id="2" author="sh">
		<sql>
			create type objekt_baum as (
			id integer,
			id_super integer,
			id_art integer,
			plan_start timestamp with time zone, -- Planned start date of object.
			plan_end timestamp with time zone, -- Planned end date of object.
			rec_start timestamp with time zone, -- Min(date) of measurement records
			rec_end timestamp with time zone,
			name text,
			path text,
			art text -- Max(date) of measurement records
			);
		</sql>
	</changeSet>

	<changeSet id="3" author="sh">
		<createProcedure>
  <![CDATA[  
  create or replace Function get_objekt_baum(_id integer,_path text, _max_depth int,_active boolean,_von timestamptz, _bis timestamptz) 
returns setof objekt_baum as
$$
declare
  rec1 record;
  rec2 record;
begin
  for rec1 in select 
  o.id,o.id_super,o.id_art,o.plan_start,o.plan_end,o.rec_start,o.rec_end,
  case when o.de is null or o.de='' then o.en else o.de end::text as name,
  _path::text as path,
  ao.uname::text as art
  from objekt o, art_objekt ao 
  where ao.id=o.id_art and o.id_super=_id
	and (not _active or isactive(o.plan_start,o.plan_end))
	and (o.rec_start,o.rec_end) overlaps (case when _von is null then o.rec_start else _von end,case when _bis is null then o.rec_end else _bis end)
   order by o.de loop
    return next rec1;
    if rec1.art not in ('messung','messung_massendaten','messung_labordaten') and _max_depth!=0 then
      for rec2 in select * from get_objekt_baum(rec1.id,_path||replace(rec1.name,'/',E'\\/')||'/',_max_depth-1,_active,_von,_bis) loop
	return next rec2;
      end loop;
    end if;
  end loop;
  return;
end
$$ language plpgsql
]]>
		</createProcedure>
	</changeSet>

	<changeSet id="4" author="sh">
		<createProcedure>
  <![CDATA[
 create or replace Function get_objekt_baum(_id integer,_id_benutzer int,_path text, _max_depth int,_active boolean,_von timestamptz, _bis timestamptz) 
returns setof objekt_baum as
$$
declare
  rec1 record;
  rec2 record;
begin
  for rec1 in select 
  o.id,o.id_super,o.id_art,o.plan_start,o.plan_end,o.rec_start,o.rec_end,
  case when o.de is null or o.de='' then o.en else o.de end::text as name,
  _path::text as path,
  ao.uname::text as art
  from objekt o, art_objekt ao 
  where ao.id=o.id_art and o.id_super=_id and check_read(o.id,_id_benutzer)
	and (not _active or isactive(o.plan_start,o.plan_end))
	and (o.rec_start,o.rec_end) overlaps (case when _von is null then o.rec_start else _von end,case when _bis is null then o.rec_end else _bis end)
        order by o.de loop
    return next rec1;
    if rec1.art not in ('messung','messung_massendaten','messung_labordaten') and _max_depth!=0 then
      for rec2 in select * from get_objekt_baum(rec1.id,_id_benutzer,_path||replace(rec1.name,'/',E'\\/')||'/',_max_depth-1,_active,_von,_bis) loop
	return next rec2;
      end loop;
    end if;
  end loop;
  return;
end
$$ language plpgsql;
 
 ]]>
		</createProcedure>
	</changeSet>

	<changeSet id="5" author="sh">

		<createProcedure>
 <![CDATA[
 create or replace Function get_web_objekt_baum(_id integer,_path text, _max_depth int) 
returns setof objekt_baum as
$$
declare
  rec1 record;
  rec2 record;
begin
  for rec1 in select 
  o.id,o.id_super,null::int,null::timestamptz,null::timestamptz,null::timestamptz,null::timestamptz,
  
  o.de::text as name,
  _path::text as path,
  o.uname::text as art
  from objekt_extern o 
  where  o.id_super=_id order by o.de loop
    return next rec1;
    if _max_depth!=0 then
      for rec2 in select * from get_web_objekt_baum(rec1.id,_path||replace(rec1.name,'/',E'\\/')||'/',_max_depth-1) loop
	return next rec2;
      end loop;
    end if;
  end loop;
  return;
end
$$ language plpgsql;
]]>
		</createProcedure>
	</changeSet>

	<changeSet id="6" author="sh">

		<createProcedure>
 <![CDATA[
create or replace function escape_path_separator(text) returns text as
$$
select replace(replace($1,E'\\slash',E'\\\\slash'),E'\\/',E'\\slash');
$$ language 'SQL';
]]>
		</createProcedure>
	</changeSet>

	<changeSet id="7" author="sh">
		<createProcedure>
<![CDATA[
create or replace function ant_to_regexp(text) returns text as
$$
select regexp_replace(replace('./'||regexp_replace(escape_path_separator($1),E'([\\^\\$\\(\\)\\[\\]\\{\\}\\.\\\\\\?\\+])',
E'\\\\\\1','g'),'**','.*'),E'([^\\.])\\*',E'\\1[^/]*','g');
$$ language 'SQL';
]]>
		</createProcedure>
	</changeSet>



	<changeSet id="8" author="sh">
		<comment>Objekt Extern ersetzt views auf public schema</comment>
		<sql>
<![CDATA[
drop view IF EXISTS v_messungen_verweis_extern;


drop view IF EXISTS v_web_mit;
drop view IF EXISTS v_web_pro;
drop view IF EXISTS v_web_objekt;
drop table IF EXISTS objekt_extern;

create table objekt_extern(
  id int not null,
  id_super int,
  de text not null,
  uname text not null,
  link text,
  mit_baum boolean,
  unique(id_super,id,mit_baum)
);
insert into objekt_extern (id, id_super, de, uname, link) values (1,null, 'All Web Objects', 'web_ordner',null);
create index objekt_extern_id_index on objekt_extern(id);
create index objekt_extern_id_super_index on objekt_extern(id_super);
create view v_web_objekt as select id,id_super,de,uname from objekt_extern;
create view v_messungen_verweis_extern as select distinct m.id as messungen_id, o.uname, o.id as objekt_id from (select messungen.id, get_objekt_super_ids(messungen.id) as id_super from messungen) m, verweis_extern v, objekt_extern o where ((v.id_auf = m.id_super) and (v.id_von = o.id)) order by m.id, o.uname, o.id;
]]>
		</sql>
	</changeSet>


	<changeSet id="9" author="oa" runOnChange="true">
		<comment>Bugfix: function check_perm: Funktion gibt false zurück, falls objekt nicht existiert  </comment>
		<createProcedure>
<![CDATA[
CREATE OR REPLACE FUNCTION check_perm(integer, integer, boolean, boolean, boolean, boolean)
  RETURNS boolean AS
$BODY$declare
rec record; 
i_id_obj alias for $1;
i_id_benutzer alias for $2;
i_read alias for $3;
i_write alias for $4;
i_exec alias for $5;
i_inherit alias for $6;
begin


/*Administratoren*/
select into rec id from benutzer 
where id=i_id_benutzer and admin;
        if found then return true; end if;
        
/* ungültige ids */ 
select into rec id from objekt where id =$1;
if not found then return false; end if;
        

/*Zugriff Benutzer*/
        select into rec * from zugriff
where id_obj=$1 and id_benutzer=$2
and (not i_read or read) 
and (not i_write or write) 
and (not i_exec or exec) 
and (not i_inherit or inherit) ;
if found then return true; end if;

/*Zugriff Gruppen*/
for rec in select 
check_perm($1,id_gruppe,i_read,i_write,i_exec,i_inherit)
from benutzer_gr where id_benutzer=$2 loop
  if rec.check_perm then return true; end if;
end loop;

/*Parent-Objekt*/
select into rec check_perm(id_super,$2,i_read,i_write,i_exec,true)
from objekt where id=$1 and id_super>=0 and id_super!=$1 and inherit_perm;

if found
then 
  return rec.check_perm;
else
  return false;
end if;

end;$BODY$
  LANGUAGE 'plpgsql' VOLATILE
  COST 100;
 ]]>
		</createProcedure>
	</changeSet>


	<changeSet author="oa" id="10">
		<comment>Bugfix: create role Ezeugen des objekts by name </comment>
		<createProcedure>
<![CDATA[
CREATE OR REPLACE FUNCTION create_role(_login character varying, _name character varying)
  RETURNS integer AS
$BODY$
declare
 rec record;
begin
select into rec create_objekt_by_name(get_userid(),null,'gruppe',_name,_name);
if rec.create_objekt_by_name>0
then
  insert into benutzer(id,login)
  values (rec.create_objekt_by_name,_login);
end if;
return rec.create_objekt_by_name;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  ]]>
		</createProcedure>
	</changeSet>


	<changeSet id="11" author="oa">
		<comment>Erweiterung Version Support in SYS_VARIABLEN</comment>
		<insert tableName="sys_variablen">
			<column name="name">version</column>
			<column name="value">1.8.0</column>
			<column name="description">Database Version</column>
		</insert>
	</changeSet>

	<changeSet id="12" author="oa">
		<comment>Entfernen von Datei Erweiterung, Anpassung copy_objekt function </comment>
		<sql>
			drop table if exists datei;
			drop table if exists his_datei;
		</sql>

		<createProcedure>
  <![CDATA[
   CREATE OR REPLACE FUNCTION copy_objekt(integer, integer)
  RETURNS integer AS
 $BODY$declare
 p_id alias for $1;
 p_id_super alias for $2;
 rec record;
 s varchar;
begin
 select into rec nextval('objekt_id')::int4 as id_seq, a.detail_table from objekt o, art_objekt a where o.id = p_id
and a.id = o.id_art;
-- objekt
 insert into objekt (id,id_super,id_art,id_cbenutzer,de, en, public_read,public_write,public_exec,inherit_perm) select
rec.id_seq,p_id_super,id_art,get_userid(),de,en,public_read,public_write,public_exec,inherit_perm
from objekt where id =p_id;
-- details
s := 'select copy_' || rec.detail_table || '(' || p_id || ',' ||
rec.id_seq ||  ');';
execute s;
 -- verweis extern
 insert into verweis_extern (id_von,id_auf,von,bis)
select id_von,rec.id_seq,von,bis from verweis_extern where id_auf =p_id;
 -- verweis
 insert into verweis (id_von,id_auf,von,bis,anteil) select id_von,rec.id_seq,von,bis,anteil from verweis where
id_auf = p_id;
 -- zugriff
 insert into zugriff (id_obj,id_benutzer,read,write,exec,inherit) values (rec.id_seq,get_userid(),true,true,true,true);
 return rec.id_seq;
end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
  ]]>
		</createProcedure>


	</changeSet>

	<changeSet id="13" author="oa" runOnChange="true">
		<comment>Upsert auf Tabelle massendaten für nachträgliches Überschreiben von Werten. Notwendig z. B. bei BayEOS Delayed Frames</comment>
		<createProcedure>
			CREATE OR REPLACE FUNCTION upsert_massendaten(_id int, _von timestamp with
			time zone, _status smallint, _wert real) RETURNS VOID AS $$
			DECLARE
			BEGIN
			UPDATE massendaten SET wert = _wert, status = _status WHERE id = _id and
			von = _von;
			IF NOT FOUND THEN
			INSERT INTO massendaten (id,von,status, wert) values
			(_id,_von,_status,_wert);
			END IF;
			END;
			$$ LANGUAGE 'plpgsql';
		</createProcedure>
	</changeSet>


	<changeSet id="14" author="oa">
		<comment>IP authentication</comment>
		<sql>
			CREATE TYPE ip_access AS ENUM ('TRUST', 'DENY', 'PASSWORD');
		</sql>
	</changeSet>

	<changeSet id="15" author="oa">
		<comment>IP authentication</comment>
		<createTable tableName="auth_ip">
			<column name="id" type="serial">
				<constraints nullable="false" />
			</column>
			<column name="network" type="inet">
				<constraints nullable="false" />
			</column>
			<column name="login" type="text">
				<constraints nullable="false" />
			</column>
			<column name="access" type="ip_access" defaultValue="'TRUST'">
				<constraints nullable="false" />
			</column>
		</createTable>
	</changeSet>

	<changeSet id="16" author="oa">
		<comment>IP authentication</comment>
		<addPrimaryKey tableName="auth_ip" columnNames="id"
			constraintName="pk_auth_ip" />
	</changeSet>

	<changeSet id="17" author="oa">
		<comment>IP authentication</comment>
		<addUniqueConstraint tableName="auth_ip"
			columnNames="network,login" constraintName="uk_auth_ip_network_login" />
	</changeSet>

	<changeSet id="18" author="oa">
		<comment>IP authentication</comment>
		<insert tableName="auth_ip">
			<column name="network">127.0.0.1</column>
			<column name="login">*</column>
			<column name="access">TRUST</column>
		</insert>
	</changeSet>

	<changeSet id="20" author="oa">
		<createProcedure>
			CREATE OR REPLACE FUNCTION get_path(integer)
			RETURNS text AS
			$BODY$declare
			rec record;
			path text;
			begin
			path:='';
			select into rec id, de, id_super from objekt where id=$1;
			if rec.id_super>0 then
			path:=rec.de;
			select into rec get_path(rec.id_super);
			if rec.get_path!='' then
			path:=rec.get_path||'/'||path;
			end if;
			else
			path:=rec.de;
			end if;
			return path;
			end;$BODY$
			LANGUAGE plpgsql VOLATILE
			COST 100;
		</createProcedure>
	</changeSet>


	<changeSet id="21" author="oa">
		<createProcedure>
	<![CDATA[
CREATE OR REPLACE FUNCTION get_objekt_super_ids(_id integer)
  RETURNS SETOF integer AS
$BODY$select id from connectby('objekt'::text, 'id_super'::text, 'id'::text, $1::text, 0) t(id integer, id_super integer, "level" integer) ;$BODY$
  LANGUAGE sql VOLATILE
  COST 100
  ROWS 1000;	 
]]>
</createProcedure>
</changeSet>

	<changeSet id="22" author="sh">
		<comment>Bugfix: Faster update on objekt timestamp border values</comment>
		<createProcedure>
<![CDATA[
create or replace function iu_objekt() returns TRIGGER as
$$
DECLARE                                                                                                           
rec RECORD;                                                                                                         
recv RECORD;                                                                                                        
BEGIN                                                                                                               
 if (NEW.id_super is null) then                                                                                     
    RETURN NEW;                                                                                                     
 end if;                                                                                                         
 -- raise notice 'iu_objekt: %',NEW.id_super;                                                                       
 -- Direkt im Baum                                                                                                  
 select into rec min(rec_start) as rmin ,max(rec_end) as rmax,min(plan_start) as pmin, max(plan_end) as pmax from  objekt where id_super = NEW.id_super;                                                                              
 update objekt set rec_start = rec.rmin, rec_end =rec.rmax, plan_start = rec.pmin, plan_end = rec.pmax where id = NEW.id_super and (rec_start>rec.rmin or rec_end<rec.rmax or plan_start>rec.pmin or plan_end<rec.pmax);
 RETURN NEW;                                                                                                        
END;
$$ language 'plpgsql';
]]>
		</createProcedure>
	</changeSet>

	<changeSet id="23" author="oa">
		<comment>DROP COLUMN auth_ldap.keystore_path, keystore provides many certs for servlet</comment>
		<dropColumn tableName="auth_ldap" columnName="keystore_path" />
	</changeSet>

	<changeSet id="24" author="oa">
		<sql>
			INSERT INTO bayeos.art_objekt (de, detail_table, en, id, kurz, uname)
			VALUES ('Web Ordner', 'web_ordner', 'Web Folder',
			nextval('objekt_id'), 'web_ordner', 'objekt_extern');
		</sql>
	</changeSet>

	<changeSet id="25" author="oa">
		<sql>
			select create_objekt_by_name(100004,100001,'objekt_extern','ObjektArt:Web Ordner','ObjektType:Web Folder');
		</sql>
	</changeSet>

	<changeSet id="26" author="oa">
		<comment>delete objekt including details in detail tables</comment>
		<createProcedure>
	<![CDATA[
	CREATE OR REPLACE FUNCTION delete_objekt(_id integer)
  	RETURNS VOID AS
	$BODY$ declare
	_tab art_objekt.detail_table%TYPE;
	_artId int;
	begin
	if (_id is null) then
 		raise exception 'Illegal argument'; 
	end if;
	
	select into _artId id_art from objekt where id = _id;
	if _artId is null then
  		raise exception 'Art Id not found'; 
	end if;
	
	select into _tab detail_table from art_objekt where id =_artId;
	if _tab is null then
  		raise exception 'Detail table name not found'; 
	end if;	
	delete from verweis where id_auf = _id;
	delete from verweis_extern where id_auf = _id;
	execute 'delete from ' || _tab || ' where id = ' || _id;
	delete from objekt where id = _id;
	end;
	$BODY$
  	LANGUAGE plpgsql VOLATILE
  	COST 100;
	 ]]>
	</createProcedure>
	</changeSet>
	
	<changeSet id="27" author="oa">
	    <addColumn tableName="auth_ldap"><column name="port" type="int"></column></addColumn>
	    <update tableName="auth_ldap">
	        <column name="port" value="636"/>
	        <where>ssl=true</where>	        
	    </update>
	    <update tableName="auth_ldap">
	        <column name="port" value="389"/>
	        <where>ssl=false</where>	        
	    </update>	    
	</changeSet>
	<changeSet id="28" author="oa">
	    <comment>Anpassungen objekt extern</comment>
	    <dropColumn tableName="objekt_extern" columnName="mit_baum"/>	    
	</changeSet>
	<changeSet id="29" author="oa">
	    <comment>Anpassungen verweis extern</comment>
		<sql>alter table verweis_extern drop constraint chk_verweis_ex_id_von_auf</sql>
	</changeSet>    
	
	<changeSet id="30" author="oa">
	<createProcedure>
	<![CDATA[
	CREATE OR REPLACE FUNCTION update_child_min_max(integer)
  RETURNS boolean AS
$BODY$declare
  rec record;
  b boolean;
 begin  
  for rec in SELECT id, id_art from objekt where id in (select t.id FROM connectby('objekt'::text, 'id'::text, 'id_super'::text, $1::text, 0) t(id integer, id_super integer, "level" integer)) and objekt.id_art in (117661,117662)
  loop
      raise notice 'Processing id:%',rec.id;
      if (rec.id_art = 117661) then
        select into b update_massendaten_min_max(rec.id);
      elsif (rec.id_art = 117662) then
        select into b update_labordaten_min_max(rec.id);
      end if;      
  end loop;
  return(true);
 end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
 ]]>
	</createProcedure>
	</changeSet>
	<changeSet id="31" author="sh">
	<createProcedure>
	<![CDATA[
	create or replace function ant_to_regexp(text) returns text as
$$
select regexp_replace(replace(replace(E'^\\./'||regexp_replace(escape_path_separator($1),E'([\\^\\$\\(\\)\\[\\]\\{\\}\\.\\\\\\?\\+])',
E'\\\\\\1','g'),'**/','(.*/|)'),'**','.*'),E'([^\\.])\\*',E'\\1[^/]*','g')||'$';
$$ language 'SQL'; 
]]> 
	</createProcedure>
	</changeSet>
	
	<changeSet id="32" author="oa">
	<comment>Bug: Invalid schema name in arch_his</comment>
	 <createProcedure>
	<![CDATA[
	 CREATE OR REPLACE FUNCTION arch_his()
  RETURNS boolean AS
$BODY$declare
 rec record;
 bol bool;
 path text;
 begin  
    select into path value from sys_variablen where name like 'arch_path';
    if not found then
     raise exception 'Archivierungspfad nicht in sys_variablen gefunden.';
    end if;

    for rec in select tablename from pg_tables where tablename like 'his_%' 
    loop
      select into bol arch_his_tab(rec.tablename, path);
    end loop;
  return(true);
 end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
	]]> 
	</createProcedure>
	
	  <createProcedure>
	<![CDATA[
	CREATE OR REPLACE FUNCTION arch_his_tab(text, text)
  RETURNS boolean AS
$BODY$declare
 seq int4;
 filename text;
 filepath text;
 begin
    select into seq nextval('bayeos.' || $1 || '_id');    
    filename :=  $1 || '_' || seq || '.cp';
    filepath := $2 || '/' || filename ;
    raise notice 'Archiviere % nach %.',$1, filepath;  
    execute 'copy bayeos.' || $1 || ' to ' || quote_literal(filepath) ;
    execute 'insert into arch_his_log (name,min_id,max_id,min_datum,max_datum,counts)  ' ||
    'select ' || quote_literal(filename) || ', min(his_id) ,max(his_id), min(his_datum), max(his_datum), count(*) from ' || $1;  
    execute 'delete from bayeos.' || $1 || ' where his_id < ' || seq;
    return(true);
 end;
$BODY$
  LANGUAGE plpgsql VOLATILE
  COST 100;
	]]> 
	</createProcedure>
	
	</changeSet>
	<changeSet id="33" author="oa">
	<comment>Bug: update on null interval values iu_objekt</comment>
	 <createProcedure>
	<![CDATA[
create or replace function iu_objekt() returns TRIGGER as
$$
DECLARE
rec RECORD;
recv RECORD;
BEGIN
 if (NEW.id_super is null) then
     RETURN NEW;
      end if;
       -- raise notice 'iu_objekt: %',NEW.id_super;
        select into rec min(rec_start) as rmin ,max(rec_end) as rmax,min(plan_start) as pmin, max(plan_end) as pmax from
	 objekt where id_super = NEW.id_super;

 update objekt set rec_start = rec.rmin, rec_end =rec.rmax, plan_start = rec.pmin, plan_end = rec.pmax
  where id = NEW.id_super and (rec_start>rec.rmin or rec_end<rec.rmax or plan_start>rec.pmin or plan_end<rec.pmax
   or rec_start is null or rec_end is null or plan_start is null or plan_end is null);
    RETURN NEW;
    END;
    $$ language 'plpgsql';
	]]> 
	</createProcedure>
	</changeSet>
	
	<changeSet id="34" author="oa">
		<preConditions onFail="MARK_RAN">
            <sqlCheck expectedResult="3">select count(*) from timezone</sqlCheck>
        </preConditions>
		<sql>
		alter SEQUENCE timezone_id_seq restart with 4 ;
		INSERT INTO timezone (name) VALUES ('Etc/GMT+12');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-2');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-3');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-4');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-5');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-6');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-7');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-9');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-10');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-11');
		INSERT INTO timezone (name) VALUES ('Etc/GMT-12');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+1');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+2');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+3');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+4');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+5');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+6');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+7');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+8');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+9');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+10');
		INSERT INTO timezone (name) VALUES ('Etc/GMT+11');
		</sql>
	</changeSet>
	
	
</databaseChangeLog>


